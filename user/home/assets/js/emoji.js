class EmojiManager {
    constructor() {
        this.emojiData = {
            smileys: ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú', 'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥'],
            people: ['üëã', 'ü§ö', 'üñêÔ∏è', '‚úã', 'üññ', 'üëå', 'ü§è', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'üñï', 'üëá', '‚òùÔ∏è', 'üëç', 'üëé', 'üëä', '‚úä', 'ü§õ', 'ü§ú', 'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù', 'üôè'],
            nature: ['üå±', 'üåø', 'üçÄ', 'üçÉ', 'üåæ', 'üåµ', 'üå≤', 'üå≥', 'üå¥', 'üå±', 'üåø', '‚òòÔ∏è', 'üçÄ', 'üçÉ', 'üåæ', 'üåµ', 'üå≤', 'üå≥', 'üå¥', 'üèîÔ∏è', '‚õ∞Ô∏è', 'üåã', 'üóª', 'üèûÔ∏è', 'üèúÔ∏è', 'üèñÔ∏è', 'üèùÔ∏è', 'üåÖ', 'üåÑ', 'üå†'],
            food: ['üçé', 'üçê', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'ü´ê', 'üçà', 'üçí', 'üçë', 'ü•≠', 'üçç', 'ü••', 'ü•ù', 'üçÖ', 'üçÜ', 'ü•ë', 'ü•¶', 'ü•¨', 'ü•í', 'üå∂Ô∏è', 'ü´ë', 'üåΩ', 'ü•ï', 'ü´í', 'üßÑ', 'üßÖ', 'ü•î'],
            activities: ['‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'ü•é', 'üéæ', 'üèê', 'üèâ', 'ü•è', 'üé±', 'ü™Ä', 'üèì', 'üè∏', 'üèí', 'üèë', 'ü•ç', 'üèè', 'ü™É', 'ü•Ö', '‚õ≥', 'ü™Å', 'üèπ', 'üé£', 'ü§ø', 'ü•ä', 'ü•ã', 'üéΩ', 'üõπ', 'üõ∑', '‚õ∏Ô∏è'],
            travel: ['üöó', 'üöï', 'üöô', 'üöå', 'üöé', 'üèéÔ∏è', 'üöì', 'üöë', 'üöí', 'üöê', 'üõª', 'üöö', 'üöõ', 'üöú', 'üèçÔ∏è', 'üõµ', 'üö≤', 'üõ¥', 'üõ∫', 'üö®', 'üöî', 'üöç', 'üöò', 'üöñ', 'üö°', 'üö†', 'üöü', 'üöÉ', 'üöã', 'üöû'],
            objects: ['üí°', 'üî¶', 'üïØÔ∏è', 'ü™î', 'üßØ', 'üõ¢Ô∏è', 'üí∏', 'üíµ', 'üí¥', 'üí∂', 'üí∑', 'ü™ô', 'üí∞', 'üí≥', 'üíé', '‚öñÔ∏è', 'ü™ú', 'üß∞', 'üîß', 'üî®', '‚öíÔ∏è', 'üõ†Ô∏è', '‚õèÔ∏è', 'üî©', '‚öôÔ∏è', 'ü™ö', 'üî´', 'üß±', 'üí£', 'üß®'],
            symbols: ['‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é', 'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò', 'üíù', 'üíü', '‚òÆÔ∏è', '‚úùÔ∏è', '‚ò™Ô∏è', 'üïâÔ∏è', '‚ò∏Ô∏è', '‚ú°Ô∏è', 'üîØ', 'üïé', '‚òØÔ∏è', '‚ò¶Ô∏è', 'üõê'],
            flags: ['üèÅ', 'üö©', 'üéå', 'üè¥', 'üè≥Ô∏è', 'üè≥Ô∏è‚Äçüåà', 'üè≥Ô∏è‚Äç‚ößÔ∏è', 'üè¥‚Äç‚ò†Ô∏è', 'üá¶üá®', 'üá¶üá©', 'üá¶üá™', 'üá¶üá´', 'üá¶üá¨', 'üá¶üáÆ', 'üá¶üá±', 'üá¶üá≤', 'üá¶üá¥', 'üá¶üá∂', 'üá¶üá∑', 'üá¶üá∏', 'üá¶üáπ', 'üá¶üá∫', 'üá¶üáº', 'üá¶üáΩ', 'üá¶üáø', 'üáßüá¶', 'üáßüáß', 'üáßüá©', 'üáßüá™', 'üáßüá´']
        };
        
        this.currentCategory = 'smileys';
        this.isPickerVisible = false;
        this.currentTargetElement = null;
        this.currentMessageId = null;
        
        this.init();
    }

    init() {
        this.setupEventListeners();
        this.populateEmojiPicker();
    }

    setupEventListeners() {
        document.querySelectorAll('.emoji-category').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const category = e.target.dataset.category;
                this.switchCategory(category);
            });
        });
        document.addEventListener('click', (e) => {
            const emojiPicker = document.getElementById('emojiPicker');
            const emojiBtn = document.getElementById('emojiBtn');
            
            if (this.isPickerVisible && 
                !emojiPicker.contains(e.target) && 
                !emojiBtn.contains(e.target) &&
                !e.target.closest('.message-action-btn[data-action="react"]')) {
                this.hideEmojiPicker();
            }
        });
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('emoji-item')) {
                this.selectEmoji(e.target.textContent);
            }
        });
    }

    populateEmojiPicker() {
        const emojiGrid = document.getElementById('emojiGrid');
        if (!emojiGrid) return;

        this.renderEmojiGrid(this.currentCategory);
    }

    renderEmojiGrid(category) {
        const emojiGrid = document.getElementById('emojiGrid');
        const emojis = this.emojiData[category] || this.emojiData.smileys;

        emojiGrid.innerHTML = emojis.map(emoji => 
            `<button class="emoji-item" title="${emoji}">${emoji}</button>`
        ).join('');
    }

    switchCategory(category) {
        document.querySelectorAll('.emoji-category').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-category="${category}"]`).classList.add('active');
        this.currentCategory = category;
        this.renderEmojiGrid(category);
    }

    toggleEmojiPicker(triggerElement) {
        const emojiPicker = document.getElementById('emojiPicker');
        
        if (this.isPickerVisible) {
            this.hideEmojiPicker();
        } else {
            this.showEmojiPicker(triggerElement);
        }
    }

    showEmojiPicker(triggerElement) {
        const emojiPicker = document.getElementById('emojiPicker');
        const rect = triggerElement.getBoundingClientRect();
        const pickerHeight = 400;
        const pickerWidth = 320;
        let top = rect.top - pickerHeight - 10;
        let left = rect.left;
        if (top < 10) {
            top = rect.bottom + 10;
        }
        
        if (left + pickerWidth > window.innerWidth - 10) {
            left = window.innerWidth - pickerWidth - 10;
        }
        
        if (left < 10) {
            left = 10;
        }
        
        emojiPicker.style.position = 'fixed';
        emojiPicker.style.top = `${top}px`;
        emojiPicker.style.left = `${left}px`;
        emojiPicker.classList.remove('hidden');
        
        this.isPickerVisible = true;
        this.currentTargetElement = triggerElement;
    }

    hideEmojiPicker() {
        const emojiPicker = document.getElementById('emojiPicker');
        emojiPicker.classList.add('hidden');
        
        this.isPickerVisible = false;
        this.currentTargetElement = null;
        this.currentMessageId = null;
    }

    selectEmoji(emoji) {
        if (this.currentMessageId) {
            this.addReactionToMessage(this.currentMessageId, emoji);
        } else if (this.currentTargetElement) {
            this.insertEmojiIntoInput(emoji);
        }
        
        this.hideEmojiPicker();
    }

    insertEmojiIntoInput(emoji) {
        const messageInput = document.getElementById('messageInput');
        if (!messageInput) return;

        const start = messageInput.selectionStart;
        const end = messageInput.selectionEnd;
        const text = messageInput.value;
        
        const newText = text.substring(0, start) + emoji + text.substring(end);
        messageInput.value = newText;
        const newCursorPos = start + emoji.length;
        messageInput.setSelectionRange(newCursorPos, newCursorPos);
        messageInput.focus();
        messageInput.dispatchEvent(new Event('input'));
    }

    addReactionToMessage(messageId, emoji) {
        window.chatManager?.toggleReaction(messageId, emoji);
    }

    showEmojiPickerForMessage(messageId, triggerElement) {
        this.currentMessageId = messageId;
        this.showEmojiPicker(triggerElement);
    }
    searchEmojis(query) {
        if (!query.trim()) {
            this.renderEmojiGrid(this.currentCategory);
            return;
        }

        const searchResults = [];
        const searchTerm = query.toLowerCase();
        Object.values(this.emojiData).forEach(categoryEmojis => {
            categoryEmojis.forEach(emoji => {
                if (this.getEmojiDescription(emoji).toLowerCase().includes(searchTerm)) {
                    searchResults.push(emoji);
                }
            });
        });

        const emojiGrid = document.getElementById('emojiGrid');
        emojiGrid.innerHTML = searchResults.map(emoji => 
            `<button class="emoji-item" title="${emoji}">${emoji}</button>`
        ).join('');
    }

    getEmojiDescription(emoji) {
        const descriptions = {
            'üòÄ': 'grinning face happy smile',
            'üòÉ': 'grinning face with big eyes happy',
            'üòÑ': 'grinning face with smiling eyes happy',
            'üòÅ': 'beaming face with smiling eyes happy',
            'üòÜ': 'grinning squinting face laugh',
            'üòÖ': 'grinning face with sweat nervous',
            'üòÇ': 'face with tears of joy laugh cry',
            'ü§£': 'rolling on the floor laughing rofl',
            'üòä': 'smiling face with smiling eyes happy',
            'üòá': 'smiling face with halo angel innocent',
            '‚ù§Ô∏è': 'red heart love',
            'üíô': 'blue heart love',
            'üíö': 'green heart love',
            'üíõ': 'yellow heart love',
            'üíú': 'purple heart love',
            'üñ§': 'black heart love',
            'ü§ç': 'white heart love',
            'üëç': 'thumbs up good yes approve',
            'üëé': 'thumbs down bad no disapprove',
            'üëã': 'waving hand hello goodbye',
            'üî•': 'fire hot flame',
            'üíØ': 'hundred points symbol perfect'
        };
        
        return descriptions[emoji] || emoji;
    }
    getFrequentlyUsed() {
        const stored = localStorage.getItem('frequentEmojis');
        return stored ? JSON.parse(stored) : ['üòÄ', 'üòÇ', '‚ù§Ô∏è', 'üëç', 'üî•'];
    }

    updateFrequentlyUsed(emoji) {
        let frequent = this.getFrequentlyUsed();
        frequent = frequent.filter(e => e !== emoji);
        frequent.unshift(emoji);
        frequent = frequent.slice(0, 30);
        
        localStorage.setItem('frequentEmojis', JSON.stringify(frequent));
    }
    applySkinTone(baseEmoji, skinTone) {
        const skinToneModifiers = {
            'light': 'üèª',
            'medium-light': 'üèº',
            'medium': 'üèΩ',
            'medium-dark': 'üèæ',
            'dark': 'üèø'
        };
        
        return baseEmoji + (skinToneModifiers[skinTone] || '');
    }
    addToRecent(emoji) {
        let recent = JSON.parse(localStorage.getItem('recentEmojis') || '[]');
        recent = recent.filter(e => e !== emoji);
        recent.unshift(emoji);
        recent = recent.slice(0, 20);
        
        localStorage.setItem('recentEmojis', JSON.stringify(recent));
        this.updateFrequentlyUsed(emoji);
    }

    getRecentEmojis() {
        return JSON.parse(localStorage.getItem('recentEmojis') || '[]');
    }
    addCustomEmoji(name, url) {
        let customEmojis = JSON.parse(localStorage.getItem('customEmojis') || '{}');
        customEmojis[name] = url;
        localStorage.setItem('customEmojis', JSON.stringify(customEmojis));
    }

    getCustomEmojis() {
        return JSON.parse(localStorage.getItem('customEmojis') || '{}');
    }
    setupEmojiAutocomplete() {
        const messageInput = document.getElementById('messageInput');
        if (!messageInput) return;

        messageInput.addEventListener('input', (e) => {
            const text = e.target.value;
            const cursorPos = e.target.selectionStart;
            const beforeCursor = text.substring(0, cursorPos);
            const match = beforeCursor.match(/:(\w+)$/);
            
            if (match) {
                this.showEmojiSuggestions(match[1], match.index, cursorPos);
            } else {
                this.hideEmojiSuggestions();
            }
        });
    }

    showEmojiSuggestions(query, startPos, endPos) {
    }

    hideEmojiSuggestions() {
    }
    getEmojiShortcodes() {
        return {
            ':smile:': 'üòä',
            ':grin:': 'üòÄ',
            ':joy:': 'üòÇ',
            ':heart:': '‚ù§Ô∏è',
            ':thumbsup:': 'üëç',
            ':thumbsdown:': 'üëé',
            ':fire:': 'üî•',
            ':100:': 'üíØ',
            ':wave:': 'üëã',
            ':clap:': 'üëè',
            ':ok:': 'üëå',
            ':pray:': 'üôè',
            ':thinking:': 'ü§î',
            ':shrug:': 'ü§∑',
            ':facepalm:': 'ü§¶',
            ':sob:': 'üò≠',
            ':sweat:': 'üòÖ',
            ':wink:': 'üòâ',
            ':confused:': 'üòï',
            ':angry:': 'üò†'
        };
    }

    replaceShortcodes(text) {
        const shortcodes = this.getEmojiShortcodes();
        let result = text;
        
        Object.entries(shortcodes).forEach(([shortcode, emoji]) => {
            result = result.replace(new RegExp(shortcode.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), emoji);
        });
        
        return result;
    }
}
window.emojiManager = new EmojiManager();
if (window.chatManager) {
    const originalToggleEmojiPicker = window.chatManager.toggleEmojiPicker;
    window.chatManager.toggleEmojiPicker = function(triggerElement) {
        window.emojiManager.toggleEmojiPicker(triggerElement);
    };
    
    window.chatManager.showEmojiPickerForMessage = function(messageId, triggerElement) {
        window.emojiManager.showEmojiPickerForMessage(messageId, triggerElement);
    };
}